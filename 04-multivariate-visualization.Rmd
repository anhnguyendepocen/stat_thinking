# Multivariate Visualization   

```{r load-packages, message = FALSE}
library(tidyverse)
library(ggformula)
library(statthink)

# Add plot theme
theme_set(theme_statthinking())
```

Real world data are never as simple as exploring a distribution of a single variable, particularly when trying to understand individual variation. In most cases attributes interact with one another, move in tandem, and many phenomena help to explain the attribute of interest. For example, when thinking about admission rates of higher education institutions, what may be some important attributes that would explain some of the reasons why higher education institutions differ in their admission rates? When thinking about the high temperature for the given day, what attributes would be helpful to understand why the high temperature on a day is different? Take a few minutes to brainstorm some ideas.

Building off of the high temperature example, we will use weather data from two seasons of cooler months of the year, October through April of 2018-2019 and 2019-2020, of various locations around the United States. This data was downloaded from the [National Centers for Environmental Information (NCEI) Climate Data Online portal](https://www.ncdc.noaa.gov/cdo-web/) and is part of the companion package, `statthink`. The locations extracted in these data are found in the northern part of the United States and include: `r distinct(us_weather, location) %>% paste(sep = ", ")`. The first few rows of the data are shown below.

```{r show-data, message=FALSE}
DT::datatable(us_weather)
```

## Multivariate Distributions
Before moving to multivariate distributions, first, we will explore a univariate distribution of the average daily temperature. The average daily temperature takes the recorded temperatures from a single day and averages those, therefore this value would fall somewhere between the high and low temperature for the day. What are some key characteristics of the average daily temperature distribution? Take a few minutes to summarize the key characteristics.

```{r temp-hist}
gf_histogram(~ drybulbtemp_avg, data = us_weather, bins = 30) %>% 
  gf_labs(x = "Average daily temperature, in Fahrenheit", 
          title = "Univariate distribution of avg daily temperature")
```

From the univariate figure of the average daily temperature, you may have noticed that there is variation in these values, with a fairly wide range considering the values. For example, there are some average daily temperatures that are below zero and some of 60 degree Fahrenheit. However, most values are between 20 and 45 or so, which is reasonable given these are cooler months of the year and mostly northern location in the United States. Finally, the distribution is unimodal and somewhat symmetric, at least not skewed enough to be too concerned. 

Earlier the question was asked what other attributes may help to explain why there are variations in high temperatures. If you did not think about that question then, we encourage you to think about this question now. What attributes could help to understand why there is such a wide range of values in the average daily temperature?

There are many answers that could be informative to this discussion, the one we will explore first is whether it snowed on a given day. This could influence the average temperature for a few reasons, first when it snows it must be cold enough for the precipitation to stay in frozen form rather than melting as it falls being at or below freezing (32 degrees Fahrenheit) ^[For more information on why it snows instead of rains, this is an informative description from the [National Snow & Ice Data Center](https://nsidc.org/cryosphere/snow/science/formation.html)]; also, if it snowed during the day it would also be less likely for the sun to be out further making the temperature less variable and likely lower during the winter months. 

### Histograms
Below is the multivariate distribution of the average daily temperature by whether it snowed or not at some point during that day. Whether it snowed or not is depicted by color in the figure, the blue color is showing the distribution of average daily temperature for days where it snowed and red is otherwise. Before we interpret the figure in more detail, the code for making this change was done by adding the snow attribute to the `fill` aesthetic using the formula syntax: `fill = ~ snow`. The `fill` aesthetic is telling the histogram bars to be colored by the different categories of the attribute of interest, here snow. The `fill` attribute for histrograms is best used when the attribute only has a few categories. 
 

```{r temp-snow-hist}
gf_histogram(~ drybulbtemp_avg, data = us_weather, bins = 30, 
             fill = ~ snow) %>%
  gf_labs(x = "Average daily temperature, in Fahrenheit", 
          title = "Multivariate distribution of avg daily temperature by whether it snowed",
          fill = "Snow?")
```

If you were to compare the distribution for the average daily temperature for days when it snowed compared to when it did not snow, what similarities and differences do you notice? Take a few minutes to try and interpret this figure, focusing on characteristics that are similar or different across days when it snowed or not. 

You may notice first that the bars are higher for the days that did not snow compared to days that it did snow. Why might this be occurring? If you said the reason is that it tends to snow less frequently, you would be correct. The bars are higher for days when it did not snow due to more data (i.e., days) where it did not snow. This characteristic of the histogram in this example makes the histogram more difficult to interpret and can even mislead when making comparisons across the two groups. We will explore a solution to this problem soon. 

Another observation you may have noticed is that it appears the temperature tends to be lower for days in which it snows compared to those that it did not snow. On average, if you estimated the location of the mean for the two groups, the average daily temperature for days where it snowed would likely be just under 30 degrees where as it would be around 45 degrees Fahrenheit for days it did not snow. You may have also noticed that the variability for days when it snowed was also lower compared to days where it did snow. Why might this occur? This is likely due to the temperature ranges where snow forms readily.

You may wonder, why are there days where the average daily temperature was about 45 degrees Fahrenheit when it generally needs to be lower than 32 degrees Fahrenheit for it to snow? There could be many explanations for this, but since the distribution is showing the average daily temperature over a 24 hour period, the weather can change quite drastically over this period. For example, it could snow at the beginning or end of the day and the rest of the day could be quite different and much warmer than when it snowed. 

Finally, you may also notice that the distribution for days when it snowed is somewhat more left skewed compared to days in which it does not snow. As snow readily forms when it is cooler, typically less than 32 degrees Fahrenheit, the temperature would commonly fall below this value when it snows. Therefore, the average temperature would be restricted by those colder values, pulling the average lower, even if it was warmer earlier or later in the day. This restriction is not found for days when it does not snow, therefore the temperatures are able to be found over a wider range of temperature values. 


### Density Curves
Often density plots are easier to visualize when there are more than one group. The other benefit of moving to a density plot is that any sample size differences across the groups are normalized automatically, which does not occur by default with the histogram. To start, we will explore the average daily temperature based on whether it snowed that day or not. For the first density curve, we will use almost the same code as the multivariate histogram. The only change in the code is to use `gf_density()` instead of `gf_histogram()`. Take a few minutes to summarize important differences in this figure compared to the multivariate histogram. 

```{r temp-density-fill}
gf_density(~ drybulbtemp_avg, data = us_weather, size = 1,
             fill = ~ snow) %>%
  gf_labs(x = "Average daily temperature, in Fahrenheit", 
          title = "Multivariate distribution of avg daily temperature by whether it snowed",
          fill = "Snow?")
```

Notice that there are two density curves, each shaded a different color, light blue for days in which it snowed, and light red for days where it did not snow. One primary difference, between the density and histogram is that the curves are normalized for sample size differences, therefore differences in heights for the two density curves can be interpreted as there being more data at that location. For example, the curve for days it snowed has a higher peak, around 30 degrees Fahrenheit, compared to the peak for days it did not snow, around 45 degrees. The higher peak here means there is more data clustered around 30 degrees for the snowy days compared to the amount of data clustered around 45 degrees for the days it did not snow. 

The normalization of sample size across the groups helps to accentuate the key differences. Namely, there are differences in where the center and amount of variation between the two groups. When plotting two groups with a histogram, the groups are plotted over top of each other which can further mask differences in the group that is plotted first. The density curve with some transparency, as depicted above, does not suffer from these problems. 

There is another plotting aesthetic that is useful to know about when using density curves. This is the `color` aesthetic which changes the colors of the line of the density curve. Similar to the `fill` aesthetic, it is possible to have the lines change color based on the snow attribute as such: `color = ~ snow`. The code below does this and also makes the lines slightly larger to view easier with the `size = 1` global aesthetic.

```{r temp-color-density}
gf_density(~ drybulbtemp_avg, data = us_weather, 
             color = ~ snow, size = 1) %>%
  gf_labs(x = "Average daily temperature, in Fahrenheit", 
          title = "Multivariate distribution of avg daily temperature by whether it snowed",
          color = "Snow?")
```

Without specifying the fill aesthetic, both groups have the same fill color below the lines, but notice that now the lines are colored instead of the entire curve being filled in. Areas that are darker gray are areas where the two groups overlap. The rest of the density curves are the same besides the appearance differences. 

It is also possible to combine the `color` and `fill` aesthetics, even with the same attribute. For example, the code below using the snow attribute for both the `color` and `fill` aesthetics. The primary difference here is that the lines are a bit larger compared to the first density figure shown. 

```{r temp-color-fill-density}
gf_density(~ drybulbtemp_avg, data = us_weather, 
           color = ~ snow, size = 1,
           fill = ~ snow) %>%
  gf_labs(x = "Average daily temperature, in Fahrenheit", 
          title = "Multivariate distribution of avg daily temperature by whether it snowed",
          fill = "Snow?",
          color = "Snow?")
```

It is also possible to use both aesthetics, but set one to be constant rather than adding the attribute to it. When there are many groups, this can be a good way to visualize more groups and not have too much color happening. In the code below, the snow attribute is specified to the `color` aesthetic, but now the `fill` aesthetic is set to a specific color, this time a shade of gray. The grayscale ranges from 0 to 100, where 0 is black and 100 is white, therefore in this case when setting `fill = 'gray75'` this would be a lighter gray as the number is closer to 100. 

```{r temp-color-fixedfill-density}
gf_density(~ drybulbtemp_avg, data = us_weather, 
           color = ~ snow, size = 1,
           fill = 'gray75') %>%
  gf_labs(x = "Average daily temperature, in Fahrenheit", 
          title = "Multivariate distribution of avg daily temperature by whether it snowed",
          color = "Snow?")
```

This results in a figure that is a bit lighter than the default gray color used in density plots. This lighter gray makes it a bit easier to see the density curves that are plotted behind. When there are more than two groups, this can be an important consideration to take into account to ensure the visualization is easier to interpret. Take the example below which instead of showing whether it snowed it shows the different locations. 

```{r temp-density-location, fig.cap = "Multivariate distribution of avg daily temperature by whether it snowed"}
gf_density(~ drybulbtemp_avg, data = us_weather, 
           color = ~ location, size = 1,
           fill = 'gray85') %>%
  gf_labs(x = "Average daily temperature, in Fahrenheit", 
          color = "")
```

In this figure, the grayscale was changed from 75 to 85 as well, but you'll notice that it is still difficult to view all of the locations. This is made more difficult here due to the locations having similar distributional centers. The next section will show an alternative visualization that can help when density curves are difficult to interpret. 

### Violin Plots
 
Violin plots are another way to make comparisons of distributions across groups. Violin plots are also easier to interpret when there are more than two groups on a single graph. Violin plots are density plots that are mirrored to be fully enclosed. Procedurally, the density curve that was shown above is mirrored or flipped across the x-axis. Let's explore an example that creates a violin plot with the `gf_violin()` function and a two-sided formula, `drybulbtemp_avg ~ snow` which will visualize the average daily temperature by whether it has snowed or not.

```{r violin-temp-snow}
gf_violin(drybulbtemp_avg ~ snow, data = us_weather) %>%
  gf_labs(y = "Average daily temperature, in Fahrenheit",
          title = 'Multivariate distribution of avg daily temperature by whether it snowed',
          x = "Snow?")
```

By default, the violin plots are oriented vertically, where the temperature is on the y-axis and whether it snowed or not is on the x-axis. This is opposite of what we have been using with histograms and density curves. Fortunately, we can change this behavior by adding a single line of code, `gf_refine(coord_flip())`. This command flips the x- and y- axes to place the average daily temperature on the x-axis. Throughout the rest of the book, any violin plots shown will have the default axes flipped for consistency with the histograms and density plots. 


```{r violin-temp-snow-flipped}
gf_violin(drybulbtemp_avg ~ snow, data = us_weather) %>%
  gf_labs(y = "Average daily temperature, in Fahrenheit",
          title = 'Multivariate distribution of avg daily temperature by whether it snowed',
          x = "Snow?") %>%
  gf_refine(coord_flip())
```

Violin plots are depicted for each group separately. This means that there will be the same number of violin plots as the number of groups that are in the attribute on the right hand side of the equation specified inside `gf_violin()`. In the example above, there is a violin plot for days it snowed and second one for days it did not snow and these violin plots are shown separately and never stacked on top of one another. This is the feature that makes these figures able to handle a larger number of groups more efficiently compared to density of histograms. 

From the figure, similar findings discussed earlier can be articulated. For example, there is a higher center and more variation on days that it did not snow. There is also evidence that the distribution for days that did snow is left-skewed whereas the distribution for days it did not snow is more symmetric. 

Aesthetically, these figures are a bit more pleasing to look at if they include a light fill color. This is done similar to the density plots shown above with the `fill = ` argument, specified as `fill = 'gray85'`.

```{r violin-temp-snow-gray}
gf_violin(drybulbtemp_avg ~ snow, data = us_weather, fill = 'gray85') %>%
  gf_labs(y = "Average daily temperature, in Fahrenheit",
          title = 'Multivariate distribution of avg daily temperature by whether it snowed', 
          x = "Snow?") %>%
  gf_refine(coord_flip())
```

Percentiles are another useful feature to aid in the comparison across groups with violin plots. These can be added with the `draw_quantiles` argument. In the below code, three percentiles are shown, the 10th, 50th, and 90th percentiles are added with the code, `draw_quantiles = c(0.1, 0.5, 0.9)`. Notice that the percentiles are represented as a proportion instead of as a percentage.

```{r violin-temp-snow-quantile, fig.cap = 'Multivariate distribution of average daily temperature by whether it snowed'}
gf_violin(drybulbtemp_avg ~ snow, data = us_weather, fill = 'gray85', 
          draw_quantiles = c(0.1, 0.5, 0.9)) %>%
  gf_labs(y = "Average daily temperature, in Fahrenheit",
          x = "Snow?") %>%
  gf_refine(coord_flip())
```

When the percentiles are added, it is now easier to compare the center of the two distributions by using the middle vertical line in each violin plot which represents the 50th percentile or median. In this violin plot, the 50th percentile is lower for days it did snow compared to days it did not snow. Furthermore, the 90th percentile is also lower than the 50th percentile for days that it did snow. This helps to provide evidence that days that it did snow tend to be much colder than typical days, as shown by the 50th percentile, when it did not snow. 

Comparing the distance between the 10th and 90th percentiles for each group can also give a sense of the range of typical values. Although this isn't the interquartile range ^[The interquartile range is the difference between the 25th and 75th percentiles], the difference between the 10th and 90th percentiles reflects a similar quantity. For days that it snowed, the 10th percentile is around 10 to 12 degrees Fahrenheit and the 90th percentile is around 37 to 40 degrees Fahrenheit. Therefore the difference would be about 25 to 30 degrees Fahrenheit. Doing the same process for days it did not snow, the 10th percentile would be around 24 degrees Fahrenheit and the 90th percentile would be around 55 degrees Fahrenheit. The difference would then be around 31 degrees Fahrenheit. This suggests that the spread of the middle 80% of the data in each group are similar, with days in which it snowed showing some evidence of being slightly less spread out over this middle 80%. 

#### Violin Plots with many groups
 
As discussed earlier, visualizing many groups can be done more easily using violin plots compared to density or histograms. This is shown below where the average daily temperature is shown for each of the 8 locations in the US weather data. The 10th, 50th, and 90th percentiles are shown as well for comparison. Take a minute to compare this figure to the one with overlapping density curves in Figure \@ref(fig:temp-density-location).


```{r}
gf_violin(drybulbtemp_avg ~ location, data = us_weather, fill = 'gray85', 
          draw_quantiles = c(.1, .5, .9)) %>%
  gf_labs(y = "Average daily temperature, in Fahrenheit",
          title = 'Multivariate distribution of avg daily temperature by location',
          x = "Location") %>%
  gf_refine(coord_flip())
```

#### Boxplots
Boxplots are another way to visualize multiple groups and typically consist of 5 number summaries plotted visually. The 5 numbers that summarize a distribution include the minimum, the 25th percentile, the 50th percentile or median, the 75th percentile, and the maximum value. Boxplots can be more complicated than this if there are values that are extreme values, sometimes referred to as outliers ^[We prefer the term extreme values as this reflects what the value is without the added jargon of an outlier. We prefer to use outliers for data that should be removed from analysis due to being from another population or not an accurate measurement.]. More on how extreme values are depicted later.

First, an example of a boxplot. The average daily temperature will be shown based on whether it snowed or not that day. The code is very similar to that of the violin plot, except the `gf_boxplot()` function is used. Take a minute to compare the final violin plot in \@ref(fig:violin-temp-snow-quantile) to the boxplot created in \@ref(fig:boxplot-temp-snow) to note key similarities and differences. Do you have a preference between the two figures?

```{r boxplot-temp-snow, fig.cap = 'Multivariate distribution of average daily temperature by whether it snowed'}
gf_boxplot(drybulbtemp_avg ~ snow, data = us_weather) %>%
  gf_labs(y = "Average daily temperature, in Fahrenheit",
          x = "Snow?") %>%
  gf_refine(coord_flip())
```

The box of the boxplot contains the middle 50% of the data and is defined by the 25th percentile as the lower/left most portion of the box, the 50th percentile or median is in the middle, and the 75th percentile is the upper/right most portion of the box. The whiskers are the lines that extend beyond the upper and lower portions of the box and will extend to the minimum or maximum in the case that there are no extreme values. 

You may notice this figure contains individual points at the upper/lower end of the boxplots (only the lower end for days in which it snowed). These are the way a boxplot labels extreme values that are 1.5 times the interquartile range from the 25th or 75th percentile. When there are points more than 1.5 times the IQR distance away from the 25th and 75th percentiles the boxplot truncates the whiskers as this point and labels any remained data as individual points. More formally, data that are extreme values are calculated based on the size of the interquartile range as:

\begin{equation}
\textrm{whisker minimum} = 25^{th} \textrm{ percentile} - 1.5 * IQR \\
\textrm{whisker maximum} = 75^{th} \textrm{ percentile} + 1.5 * IQR 
(\#eq:extreme-boxplot)
\end{equation}

These equations are how far the whiskers will extend above and below the box of the boxplot and any data outside these locations are commonly notated as individual data points. In Figure \@ref(fig:boxplot-temp-snow), the data shown as black circles are those labeled as extreme values, or more than 1.5 times the IQR away from the 25th or 75th percentiles. 

## Facetting
 
Facetting is another way to explore distributions of two or more variables.

```{r}
gf_violin(drybulbtemp_avg ~ location, data = us_weather, fill = 'gray85', 
          draw_quantiles = c(.1, .5, .9)) %>%
  gf_labs(y = "Average daily temperature, in Fahrenheit",
          title = 'Multivariate distribution of avg daily temperature by location',
          x = "Location") %>%
  gf_refine(coord_flip()) %>%
  gf_facet_wrap(~ snow)
```



## Considering Groups
We've spent a lot of time trying to reason about other variables that may be important in explaining variation in our variable of interest. So far we have only explored the variable without considering other variables, in practice that is not that useful.

Instead, it is common to compute conditional statistics based on other characteristics in the data. An example may help to show the idea more clearly. 

```{r} 
us_weather %>% 
  df_stats(drybulbtemp_max ~ location, median) 
``` 

Presented above are the conditional medians for the higher education institutions in different areas of the country. More specifically, the data are essentially split into subgroups and the median is computed for each of those subgroups instead of pooling all institutions into a single data frame. The formula syntax is now `outcome ~ grouping` where the variable of interest (i.e. commonly a numeric variable) and the variable to the right of the `~` is the grouping variable. This syntax is similar to the violin plots that were created earlier. 

Can you see differences in the admission rates across the regions? 

One thing that is useful to add in when computing conditional statisics, is how many data points are in each group. This is particularly useful when the groups are different sizes, which is common. To do this, we can add another function to the `df_stats()` function. 

```{r} 
us_weather %>% 
 df_stats(drybulbtemp_max ~ location, median, length) 
``` 

This adds another columns which represents the number of observations that went into the median calculation for each group. The syntax above also shows that you can add additional functions separated by a comma in the `df_stats()` function and are not limited to a single function. We will take advantage of this feature later on. 

### Adding additional groups 
What if we thought more than one variable was important in explaining variation in the outcome variable? These can also be added to the `df_stats()` function for additional conditional statistics. The key is to add another variable to the right-hand side of the formula argument. More than one variable are separated with a `+` symbol. 

```{r} 
us_weather %>% 
   df_stats(drybulbtemp_max ~ location + month, median, length) 
``` 

## Other statistics of center 
So far we have been discussing the median. The median attempts to provide a single number summary for the center of the distribution. It is a robust statistic, but likely isn't the most popular statistic to provide a location for the center of a distribution. The mean is often more commonly used as a measure of the center of a distribution. Part of this is due to the usage of the mean in common statistical methods and the mean also uses the values of all the data in the calculation. The median only considers the values of the middle score or scores, therefore this statistic is less sensitive to extreme values than the mean. I like to look at both statistics and this can provide some insight into the distribution of interest. We can add the mean using the `df_stats()` function by adding the function `mean`. 

```{r} 
stats_compute <- us_weather %>% 
 df_stats(drybulbtemp_max ~ location, median, mean, length) 
stats_compute 
``` 

Do you notice any trends in the direction the mean and median typically follow? More specifically, is the mean typically larger than the median or vice versa? 

Let's visualize them. 

```{r} 
gf_histogram(~ drybulbtemp_max, data = us_weather, bins = 30) %>% 
  gf_facet_wrap(~ location) %>% 
  gf_vline(color = 'blue', xintercept = ~ median_drybulbtemp_max, 
           data = stats_compute, size = 1) %>% 
  gf_vline(color = 'lightblue', xintercept = ~ mean_drybulbtemp_max, 
           data = stats_compute, size = 1) %>%
  gf_labs(x = 'Maxmimum daily temperature')
``` 

What is different about the distributions that have larger differences in the mean and median? 

## Measures of Variation 

So far we have focused primarily on applying functions to columns of data to provide a single numeric summary for where the center of the distribution may lie. The center of the distribution is important, however the primary goal in research and with statistics is to try to understand the variation in the distribution. 

One crude measure of variation that is intuitive is the range of a variable. The range is the difference between the smallest and the largest number in the data. We can compute this with the `df_stats()` function. 

```{r} 
 us_weather %>% 
   df_stats(~ drybulbtemp_max, range) 
``` 

The details of the `df_stats()` function are in the previous course notes. The output for this computation returns two values, the minimum and maximum value in the data and unsurprisingly, is 0 and 1 respectively.  

### Robust measure of variation 
The idea behind the IQR representing differences in percentiles allows us to extend this to different percentiles that may be more directly interpretable for a given situation. For example, suppose we wanted to know how spread out the middle 80% of the distribution is. We can do this directly by computing the 90th and 10th percentiles and finding the difference between the two. 

```{r} 
 mid_80 <- us_weather %>% 
   df_stats(~ drybulbtemp_max, quantile(c(0.1, 0.9)), nice_names = TRUE) 
 mid_80 
``` 

As you can see, once you extend the amount of the distribution contained, the distance increases, now to 0.555 or 55.5% the the range of the middle 80% of the admission rate distribution. We can also visualize what this looks like. 

```{r} 
 gf_histogram(~ drybulbtemp_max, data = us_weather, 
              bins = 30, color = 'black') %>% 
   gf_vline(color = 'blue', xintercept = ~ value, 
            data = gather(mid_80), size = 1) %>%
  gf_labs(x = 'Maxmimum daily temperature')
``` 

We can also view the exact percentages using the empirical cumulative density function. 

```{r} 
 gf_ecdf(~ drybulbtemp_max, data = us_weather) %>% 
   gf_vline(color = 'blue', xintercept = ~ value, data = gather(mid_80), size = 1) %>%
  gf_labs(x = 'Maxmimum daily temperature')
``` 

### Variation by Group 
These statistics can also be calculated by different grouping variables similar to what was done with statisitcs of center. Now the variable of interest is on the left-hand side of the equation and the grouping variable is on the right hand side. 

```{r} 
 iqr_groups <- us_weather %>% 
   df_stats(drybulbtemp_max ~ location, IQR, quantile(c(0.25, 0.75)), 
            nice_names = TRUE) 
 iqr_groups 
``` 

This can also be visualized to see how these statistics vary across the groups. 

```{r} 
 gf_histogram(~ drybulbtemp_max, data = us_weather, bins = 30, color = 'black') %>% 
   gf_vline(color = 'blue', xintercept = ~ value,  
      data = filter(pivot_longer(iqr_groups, IQR_drybulbtemp_max:'X75.'), 
                    name %in% c('X25.', 'X75.')), size = 1) %>% 
   gf_facet_wrap(~ location) %>%
  gf_labs(x = 'Maxmimum daily temperature')
``` 

```{r} 
 gf_ecdf(~ drybulbtemp_max, data = us_weather) %>% 
   gf_vline(color = 'blue', xintercept = ~ value,  
      data = filter(pivot_longer(iqr_groups, IQR_drybulbtemp_max:'X75.'), 
                    name %in% c('X25.', 'X75.')), size = 1) %>% 
   gf_facet_wrap(~ location) %>%
  gf_labs(x = 'Maxmimum daily temperature')
``` 

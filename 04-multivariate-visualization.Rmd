# Multivariate Visualization   

```{r load-packages, message = FALSE}
library(tidyverse)
library(ggformula)
library(statthink)

# Add plot theme
theme_set(theme_statthinking())
```

Real world data are never as simple as exploring a distribution of a single variable, particularly when trying to understand individual variation. In most cases attributes interact with one another, move in tandem, and many phenomena help to explain the attribute of interest. For example, when thinking about admission rates of higher education institutions, what may be some important attributes that would explain some of the reasons why higher education institutions differ in their admission rates? When thinking about the high temperature for the given day, what attributes would be helpful to understand why the high temperature on a day is different? Take a few minutes to brainstorm some ideas.

Building off of the high temperature example, we will use weather data from two seasons of cooler months of the year, October through April of 2018-2019 and 2019-2020, of various locations around the United States. This data was downloaded from the [National Centers for Environmental Information (NCEI) Climate Data Online portal](https://www.ncdc.noaa.gov/cdo-web/) and is part of the companion package, `statthink`. The locations extracted in these data are found in the northern part of the United States and include: `r distinct(us_weather, location) %>% paste(sep = ", ")`. The first few rows of the data are shown below.

```{r show-data, message=FALSE}
DT::datatable(us_weather)
```

## Multivariate Distributions
Before moving to multivariate distributions, first, we will explore a univariate distribution of the average daily temperature. The average daily temperature takes the recorded temperatures from a single day and averages those, therefore this value would fall somewhere between the high and low temperature for the day. What are some key characteristics of the average daily temperature distribution? Take a few minutes to summarize the key characteristics.

```{r}
gf_histogram(~ drybulbtemp_avg, data = us_weather, bins = 30) %>% 
  gf_labs(x = "Average daily temperature, in Fahrenheit", 
          title = "Univariate distribution of average daily temperature")
```

From the univariate figure of the average daily temperature, you may have noticed that there is variation in these values, with a fairly wide range considering the values. For example, there are some average daily temperatures that are below zero and some of 60 degree Fahrenheit. However, most values are between 20 and 45 or so, which is reasonable given these are cooler months of the year and mostly northern location in the United States. Finally, the distribution is unimodal and somewhat symmetric, at least not skewed enough to be too concerned. 

Earlier the question was asked what other attributes may help to explain why there are variations in high temperatures. If you did not think about that question then, we encourage you to think about this question now. What attributes could help to understand why there is such a wide range of values in the average daily temperature?

There are many answers that could be informative to this discussion, the one we will explore first is whether it snowed on a given day. This could influence the average temperature for a few reasons, first when it snows it must be cold enough for the precipitation to stay in frozen form rather than melting as it falls being at or below freezing (32 degrees Fahrenheit) ^[For more information on why it snows instead of rains, this is an informative description from the [National Snow & Ice Data Center](https://nsidc.org/cryosphere/snow/science/formation.html)]; also, if it snowed during the day it would also be less likely for the sun to be out further making the temperature less variable and likely lower during the winter months. 

Below is the multivariate distribution of the average daily temperature by whether it snowed or not at some point during that day. Whether it snowed or not is depicted by color in the figure, the blue color is showing the distribution of average daily temperature for days where it snowed and red is otherwise. Before we interpret the figure in more detail, the code for making this change was done by adding the snow attribute to the `fill` aesthetic using the formula syntax: `fill = ~ snow`. The `fill` aesthetic is telling the histogram bars to be colored by the different categories of the attribute of interest, here snow. The `fill` attribute for histrograms is best used when the attribute only has a few categories. 
 

```{r}
gf_histogram(~ drybulbtemp_avg, data = us_weather, bins = 30, 
             fill = ~ snow) %>%
  gf_labs(x = "Average daily temperature, in Fahrenheit", 
          title = "Multivariate distribution of average daily temperature by whether it snowed that day",
          fill = "")
```

If you were to compare the distribution for the average daily temperature for days when it snowed compared to when it did not snow, what similarities and differences do you notice? Take a few minutes to try and interpret this figure, focusing on characteristics that are similar or different across days when it snowed or not. 

You may notice first that the bars are higher for the days that did not snow compared to days that it did snow. Why might this be occurring? If you said the reason is that it tends to snow less frequently, you would be correct. The bars are higher for days when it did not snow due to more data (i.e., days) where it did not snow. This characteristic of the histogram in this example makes the histogram more difficult to interpret and can even mislead when making comparisons across the two groups. We will explore a solution to this problem soon. 

Another observation you may have noticed is that it appears the temperature tends to be lower for days in which it snows compared to those that it did not snow. On average, if you estimated the location of the mean for the two groups, the average daily temperature for days where it snowed would likely be just under 30 degrees where as it would be around 45 degrees Fahrenheit for days it did not snow. You may have also noticed that the variability for days when it snowed was also lower compared to days where it did snow. Why might this occur? This is likely due to the temperature ranges where snow forms readily.

You may wonder, why are there days where the average daily temperature was about 45 degrees Fahrenheit when it generally needs to be lower than 32 degrees Fahrenheit for it to snow? There could be many explanations for this, but since the distribution is showing the average daily temperature over a 24 hour period, the weather can change quite drastically over this period. For example, it could snow at the beginning or end of the day and the rest of the day could be quite different and much warmer than when it snowed. 

Finally, you may also notice that the distribution for days when it snowed is somewhat more left skewed compared to days in which it does not snow. As snow readily forms when it is cooler, typically less than 32 degrees Fahrenheit, the temperature would commonly fall below this value when it snows. Therefore, the average temperature would be restricted by those colder values, pulling the average lower, even if it was warmer earlier or later in the day. This restriction is not found for days when it does not snow, therefore the temperatures are able to be found over a wider range of temperature values. 


### Multivariate Density
Often density plots are easier to visualize when there are more than one group. To plot more than one density curve, we need to specify the color argument instead of fill.

```{r}
gf_density(~ drybulbtemp_avg, data = us_weather, size = 1,
             color = ~ snow) %>%
  gf_labs(x = "Average daily temperature, in Fahrenheit", 
          title = "Multivariate distribution of average daily temperature by whether it snowed that day",
          color = "")
```

```{r}
gf_density(~ drybulbtemp_avg, data = us_weather, size = 1,
             fill = ~ snow) %>%
  gf_labs(x = "Average daily temperature, in Fahrenheit", 
          title = "Multivariate distribution of average daily temperature by whether it snowed that day",
          fill = "")
```

```{r}
gf_density(~ drybulbtemp_avg, data = us_weather, color = ~ factor(snow), 
           fill = ~ snow, size = 1) %>%
  gf_labs(x = "Average daily temperature, in Fahrenheit", 
          title = "Multivariate distribution of average daily temperature by whether it snowed that day",
          fill = "",
          color = "")
```

```{r}
gf_density(~ drybulbtemp_avg, data = us_weather, color = ~ snow, 
           fill = 'gray75', size = 1) %>%
  gf_labs(x = "Average daily temperature, in Fahrenheit", 
          title = "Multivariate distribution of average daily temperature by whether it snowed that day",
          color = "")
```
## Violin Plots
 
Violin plots are another way to make comparisons of distributions across groups. Violin plots are also easier to show more groups on a single graph. Violin plots are density plots that are mirrored to be fully enclosed. Best to explore with an example.

```{r}
gf_violin(drybulbtemp_avg ~ snow, data = us_weather) %>%
  gf_labs(y = "Average daily temperature, in Fahrenheit",
          title = 'Multivariate distribution of average daily temperature by whether it snowed that day',
          x = "Snow?")
```

```{r}
gf_violin(drybulbtemp_avg ~ snow, data = us_weather) %>%
  gf_labs(y = "Average daily temperature, in Fahrenheit",
          title = 'Multivariate distribution of average daily temperature by whether it snowed that day',
          x = "Snow?") %>%
  gf_refine(coord_flip())
```

Aesthetically, these figures are a bit more pleasing to look at if they include a light fill color. This is done similar to the density plots shown above with the `fill = ` argument.

```{r}
gf_violin(drybulbtemp_avg ~ snow, data = us_weather, fill = 'gray85') %>%
  gf_labs(y = "Average daily temperature, in Fahrenheit",
          title = 'Multivariate distribution of average daily temperature by whether it snowed that day', 
          x = "Snow?") %>%
  gf_refine(coord_flip())
```

Adding quantiles are useful to aid in the comparison with the violin plots. These can be added with the `draw_quantiles` argument.

```{r}
gf_violin(drybulbtemp_avg ~ snow, data = us_weather, fill = 'gray85', 
          draw_quantiles = c(0.1, 0.5, 0.9)) %>%
  gf_labs(y = "Average daily temperature, in Fahrenheit",
          title = 'Multivariate distribution of average daily temperature by whether it snowed that day',
          x = "Snow?") %>%
  gf_refine(coord_flip())
```
### Violin Plots with many groups
 
Many groups are more easily shown in the violin plot framework.

With many groups, it is often of interest to put the long x-axis labels representing each group on the y-axis so that it reads the correct direction and the labels do not run into each other. This can be done with the `gf_refine()` function with `coord_flip()`.

```{r}
gf_violin(drybulbtemp_avg ~ location, data = us_weather, fill = 'gray85', 
          draw_quantiles = c(.1, .5, .9)) %>%
  gf_labs(y = "Average daily temperature, in Fahrenheit",
          title = 'Multivariate distribution of average daily temperature by location',
          x = "Location") %>%
  gf_refine(coord_flip())
```

## Facetting
 
Facetting is another way to explore distributions of two or more variables.

```{r}
gf_violin(drybulbtemp_avg ~ location, data = us_weather, fill = 'gray85', 
          draw_quantiles = c(.1, .5, .9)) %>%
  gf_labs(y = "Average daily temperature, in Fahrenheit",
          title = 'Multivariate distribution of average daily temperature by location',
          x = "Location") %>%
  gf_refine(coord_flip()) %>%
  gf_facet_wrap(~ snow)
```



## Considering Groups
We've spent a lot of time trying to reason about other variables that may be important in explaining variation in our variable of interest. So far we have only explored the variable without considering other variables, in practice that is not that useful.

Instead, it is common to compute conditional statistics based on other characteristics in the data. An example may help to show the idea more clearly. 

```{r} 
us_weather %>% 
  df_stats(drybulbtemp_max ~ location, median) 
``` 

Presented above are the conditional medians for the higher education institutions in different areas of the country. More specifically, the data are essentially split into subgroups and the median is computed for each of those subgroups instead of pooling all institutions into a single data frame. The formula syntax is now `outcome ~ grouping` where the variable of interest (i.e. commonly a numeric variable) and the variable to the right of the `~` is the grouping variable. This syntax is similar to the violin plots that were created earlier. 

Can you see differences in the admission rates across the regions? 

One thing that is useful to add in when computing conditional statisics, is how many data points are in each group. This is particularly useful when the groups are different sizes, which is common. To do this, we can add another function to the `df_stats()` function. 

```{r} 
us_weather %>% 
 df_stats(drybulbtemp_max ~ location, median, length) 
``` 

This adds another columns which represents the number of observations that went into the median calculation for each group. The syntax above also shows that you can add additional functions separated by a comma in the `df_stats()` function and are not limited to a single function. We will take advantage of this feature later on. 

### Adding additional groups 
What if we thought more than one variable was important in explaining variation in the outcome variable? These can also be added to the `df_stats()` function for additional conditional statistics. The key is to add another variable to the right-hand side of the formula argument. More than one variable are separated with a `+` symbol. 

```{r} 
us_weather %>% 
   df_stats(drybulbtemp_max ~ location + month, median, length) 
``` 

## Other statistics of center 
So far we have been discussing the median. The median attempts to provide a single number summary for the center of the distribution. It is a robust statistic, but likely isn't the most popular statistic to provide a location for the center of a distribution. The mean is often more commonly used as a measure of the center of a distribution. Part of this is due to the usage of the mean in common statistical methods and the mean also uses the values of all the data in the calculation. The median only considers the values of the middle score or scores, therefore this statistic is less sensitive to extreme values than the mean. I like to look at both statistics and this can provide some insight into the distribution of interest. We can add the mean using the `df_stats()` function by adding the function `mean`. 

```{r} 
stats_compute <- us_weather %>% 
 df_stats(drybulbtemp_max ~ location, median, mean, length) 
stats_compute 
``` 

Do you notice any trends in the direction the mean and median typically follow? More specifically, is the mean typically larger than the median or vice versa? 

Let's visualize them. 

```{r} 
gf_histogram(~ drybulbtemp_max, data = us_weather, bins = 30) %>% 
  gf_facet_wrap(~ location) %>% 
  gf_vline(color = 'blue', xintercept = ~ median_drybulbtemp_max, 
           data = stats_compute, size = 1) %>% 
  gf_vline(color = 'lightblue', xintercept = ~ mean_drybulbtemp_max, 
           data = stats_compute, size = 1) %>%
  gf_labs(x = 'Maxmimum daily temperature')
``` 

What is different about the distributions that have larger differences in the mean and median? 

## Measures of Variation 

So far we have focused primarily on applying functions to columns of data to provide a single numeric summary for where the center of the distribution may lie. The center of the distribution is important, however the primary goal in research and with statistics is to try to understand the variation in the distribution. 

One crude measure of variation that is intuitive is the range of a variable. The range is the difference between the smallest and the largest number in the data. We can compute this with the `df_stats()` function. 

```{r} 
 us_weather %>% 
   df_stats(~ drybulbtemp_max, range) 
``` 

The details of the `df_stats()` function are in the previous course notes. The output for this computation returns two values, the minimum and maximum value in the data and unsurprisingly, is 0 and 1 respectively.  

### Robust measure of variation 
The idea behind the IQR representing differences in percentiles allows us to extend this to different percentiles that may be more directly interpretable for a given situation. For example, suppose we wanted to know how spread out the middle 80% of the distribution is. We can do this directly by computing the 90th and 10th percentiles and finding the difference between the two. 

```{r} 
 mid_80 <- us_weather %>% 
   df_stats(~ drybulbtemp_max, quantile(c(0.1, 0.9)), nice_names = TRUE) 
 mid_80 
``` 

As you can see, once you extend the amount of the distribution contained, the distance increases, now to 0.555 or 55.5% the the range of the middle 80% of the admission rate distribution. We can also visualize what this looks like. 

```{r} 
 gf_histogram(~ drybulbtemp_max, data = us_weather, 
              bins = 30, color = 'black') %>% 
   gf_vline(color = 'blue', xintercept = ~ value, 
            data = gather(mid_80), size = 1) %>%
  gf_labs(x = 'Maxmimum daily temperature')
``` 

We can also view the exact percentages using the empirical cumulative density function. 

```{r} 
 gf_ecdf(~ drybulbtemp_max, data = us_weather) %>% 
   gf_vline(color = 'blue', xintercept = ~ value, data = gather(mid_80), size = 1) %>%
  gf_labs(x = 'Maxmimum daily temperature')
``` 

### Variation by Group 
These statistics can also be calculated by different grouping variables similar to what was done with statisitcs of center. Now the variable of interest is on the left-hand side of the equation and the grouping variable is on the right hand side. 

```{r} 
 iqr_groups <- us_weather %>% 
   df_stats(drybulbtemp_max ~ location, IQR, quantile(c(0.25, 0.75)), 
            nice_names = TRUE) 
 iqr_groups 
``` 

This can also be visualized to see how these statistics vary across the groups. 

```{r} 
 gf_histogram(~ drybulbtemp_max, data = us_weather, bins = 30, color = 'black') %>% 
   gf_vline(color = 'blue', xintercept = ~ value,  
      data = filter(pivot_longer(iqr_groups, IQR_drybulbtemp_max:'X75.'), 
                    name %in% c('X25.', 'X75.')), size = 1) %>% 
   gf_facet_wrap(~ location) %>%
  gf_labs(x = 'Maxmimum daily temperature')
``` 

```{r} 
 gf_ecdf(~ drybulbtemp_max, data = us_weather) %>% 
   gf_vline(color = 'blue', xintercept = ~ value,  
      data = filter(pivot_longer(iqr_groups, IQR_drybulbtemp_max:'X75.'), 
                    name %in% c('X25.', 'X75.')), size = 1) %>% 
   gf_facet_wrap(~ location) %>%
  gf_labs(x = 'Maxmimum daily temperature')
``` 
